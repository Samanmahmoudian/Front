<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call</title>
    <style>
        video {
            width: 45%;
            margin: 10px;
        }
        #localVideo {
            transform: rotateY(180deg); /* Mirror the local video feed */
        }
    </style>
</head>
<body>
    <h1>WebRTC Video Call</h1>
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>
    <br>


    <script src="https://cdn.socket.io/4.4.0/socket.io.min.js"></script>
    <script>
        const socket = io('wss://video-call-uylq.onrender.com'); // Connect to your NestJS WebSocket server

        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        let localStream;
        let peerConnection;
        const peerConnectionConfig = {
  iceServers: [
    // ✅ Free STUN Servers
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" },
    { urls: "stun:stun2.l.google.com:19302" },
    { urls: "stun:stun3.l.google.com:19302" },
    { urls: "stun:stun4.l.google.com:19302" },
    { urls: "stun:stun.services.mozilla.com" },

    // ✅ Free TURN Servers (Limited Usage)
    {
      urls: "turn:relay.metered.ca:80",
      username: "free",
      credential: "free"
    },
    {
      urls: "turn:relay.metered.ca:443",
      username: "free",
      credential: "free"
    },
    {
      urls: "turn:global.relay.metered.ca:80",
      username: "free",
      credential: "free"
    },
    {
      urls: "turn:global.relay.metered.ca:443",
      username: "free",
      credential: "free"
    }
  ]
};



        // Get local media (video and audio)
        async function getLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
            } catch (err) {
                console.error('Error accessing media devices.', err);
            }
        }

        // Set up the peer connection and start the call
        async function startCall() {
            await getLocalStream();

            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            // Add tracks to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
        console.log("ICE Candidate:", event.candidate);
        socket.emit('ice-candidate' , event.candidate)
    } else {
        console.log("ICE Gathering Complete");
    }
};


            peerConnection.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
            };

            // Create an offer and send it to the signaling server
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit('offer', offer);
        }

        // Handle offer from another client
        socket.on('offer', async (offer) => {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

            // Create an answer and send it back
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('answer', answer);
        });

        // Handle answer from another client
        socket.on('answer', (answer) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
           socket.emit('meow' , 'meow')
           alert('meow')
        });

        // Handle ICE candidates
        socket.on('ice-candidate', (candidate) => {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        });

        // Start the call when the button is clicked
        window.onload = startCall()
    </script>
</body>
</html>
